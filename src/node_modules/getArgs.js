const bigNumber = require('bignumber.js')
const ethers = require('ethers')
const convertToEther = require('convertToEther')

module.exports = getArgs

function getArgs( element, selector ) {
  var args = []
  var overrides = {}
  var fields = element.querySelectorAll(`[class^=${selector}]`)
  for (var i=0; i<fields.length; i++) {
    var x = fields[i]
    let title = x.children[0].title
     /* -----------------------------------------
                       PAYABLE
    --------------------------------------------*/
    if (title.includes('payable')) {
      var inputs = x.querySelector("[class^='inputArea']").children
      var amount = inputs[0].value
      var currency = inputs[1].value
      // The amount to send with the transaction (i.e. msg.value)
      overrides.gasLimit = 3000000
      overrides.value = convertToEther(currency, amount)
      /* -----------------------------------------
                    NOT PAYABLE
     --------------------------------------------*/
    } else {
      // ------------ ARRAY ---------------------
      if (title.includes('[')) {
        var argumentsInArr = []
        // ARRAY of BOOL
        if (title.includes('bool')) {
        let inputs = x.querySelectorAll("[class^='booleanField']")
        inputs.forEach(y => {
          argumentsInArr.push(getBool(y))
        })
      }
      // ARRAY of INT/UINT
      else if (title.includes('int')) {
        let inputs = x.querySelectorAll("[class^='integerValue']")
        inputs.forEach(y => {
          argumentsInArr.push(getArgument(y, y.value))
        })
      }
      // ARRAY of BYTES
      else if (title.includes('byte')) {
        let inputs = x.querySelectorAll("[class^='byteField']")
        inputs.forEach(y => {
          let el = y.querySelector('input')
          argumentsInArr.push(getByte(el))
        })
      } else {
        // ARRAY of OTHER TYPES
        var inputs = x.querySelectorAll('input')
        inputs.forEach(z => {
          let el = z
          let val = z.value
          argumentsInArr.push(getArgument(el, val))
        })
      }
      args.push(argumentsInArr)
      }
      // ------------ NOT ARRAY ---------------------
      // BOOLEAN
      else if (title.includes('bool')) {
        var boolField = x.querySelector("[class^='booleanField']")
        args.push(getBool(boolField))
      }
      // BYTE
      else if (title.includes('byte')) {
        var el = x.querySelector('input')
        args.push(getByte(el))
      }
      else {
      // OTHER TYPES
        let el = title.includes('int') ? x.querySelectorAll('input')[1] : x.querySelector('input')
        let val = el.value
        args.push(getArgument(el, val))
      }
    }

  }
  return {args, overrides}
}

function getByte (el) {
  return el.value
}

function getBool (boolField) {
  var val
  let falseField = boolField.children[0]
  let trueField = boolField.children[1]
  if (falseField.dataset.state === "active") val = false
  else if (trueField.dataset.state === "active") val = true
  return val
}

function getArgument(el, val) {
  var argument
  if ((el.dataset.type.search(/\buint/) != -1) || (el.dataset.type.search(/\bint/) != -1) || (el.dataset.type.search(/\bfixed/) != -1)) {
    if (val > Number.MAX_SAFE_INTEGER) {
      let number = bigNumber(Number(val)).toFixed(0)
      argument = ethers.utils.bigNumberify(number.toString())
    } else {
      argument = Number(val)
    }
  }
  if (el.dataset.type.search(/\bbyte/) != -1) {
    argument = ethers.utils.formatBytes32String(val)
  }
  if (el.dataset.type.search(/\bstring/) != -1) argument = val
  if (el.dataset.type.search(/\baddress/) != -1) argument = val
  return argument
}
